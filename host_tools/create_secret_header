#!/usr/bin/python3 -u

import logging
from pathlib import Path
import os
from util import print_banner, FIRMWARE_ROOT, LOG_FORMAT

logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
log = logging.getLogger(Path(__file__).name)

AES_KEY_SIZE = 32

def write_key_bin(key, file_name):
    file_name = '/secrets/' + file_name
    try:
        with open(file_name, "wb") as file:
            # Print the success message
            file.write(key)
    # Raise error if the file is opened before
    except IOError:
        log.info("Failed to open the file.")

def write_eeprom_bin(key_v, key_f, key_c, public_key):
    file_name = '/secrets/eeprom.bin'
    #file_name = 'eeprom.bin'
    try:
        with open(file_name, "wb") as file:
            # Print the success message
            file.write(key_v)
            file.write(key_f)
            file.write(key_c)
            file.write(public_key)
            log.info("-------------Writing eeprom data: Done-------------")
    # Raise error if the file is opened before
    except IOError:
        log.info("Failed to open the file.")

def get_public_key():
    try:
        with open("/host_tools/rsa/host_publicKey", "rb") as file:
            # Print the success message
            public_key = file.read()
            return public_key
    # Raise error if the file is opened before
    except IOError:
        log.info("Failed to open the public key file.")
# def write_bootloader_header(file_name, key_f, key_c, key_v):

#     try:
#         with open(file_name, "w") as secret_header_file:
#             # Print the success message
#             secret_header_file.write(f'''
# #ifndef KEY_H
# #define KEY_H
# #include <stdint.h>

# #define GCM_KEY_LENGTH {AES_KEY_SIZE}
# uint8_t key_f [{AES_KEY_SIZE}] = {{{", ".join([str(hex(u)) for u in key_f])}}};
# uint8_t key_c [{AES_KEY_SIZE}] = {{{", ".join([str(hex(u)) for u in key_c])}}};
# uint8_t key_v [{AES_KEY_SIZE}] = {{{", ".join([str(hex(u)) for u in key_v])}}};
#             ''')
#     # Raise error if the file is opened before
#             secret_header_file.write(f'''
# #endif
#             ''')
#     except IOError:
#         log.info("Failed to open the file.")


def generate_key():
    key = os.urandom(AES_KEY_SIZE)
    # key_list = list(key)
    # log.info('[{}]'.format(', '.join(hex(x) for x in key_list)))
    return key

def main():

    print_banner("Generating SAFFIRe secrets")
    
    key_f = generate_key()
    key_c = generate_key()
    key_v = generate_key()

    write_key_bin(key_f, "keyf.bin")
    write_key_bin(key_c, "keyc.bin")
    write_key_bin(key_v, "keyv.bin")

    log.info("-------------Output binary key: Done-------------")
    # write_bootloader_header("key.h", key_f, key_c, key_v)
    # log.info("-------------Output bootloader key header: Done-------------")
    ivf = os.urandom(12)
    ivc = os.urandom(12)
    write_key_bin(ivf, "ivf.bin")

    # cipher = AES.new(key_f, AES.MODE_GCM, nonce=ivf)
    # plaintext = b"ECTF 2022 should be better"
    # log.info(len(plaintext))
    # write_key_bin(plaintext, "plaintext.bin")
    #ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    # log.info("Cipher text:")
    # log.info(ciphertext)
    # write_key_bin(ciphertext, "ciphertext.bin")
    # log.info(len(ciphertext))
    # log.info("Tag:")
    # log.info(len(tag))'/secrets/' + 
    # write_key_bin(tag, "tag.bin")
   # cipher = AES.new(key_f, AES.MODE_GCM, nonce=ivf)
    # plaintext = cipher.decrypt_and_verify(ciphertext=ciphertext, received_mac_tag=tag)
    # log.info(plaintext)
    # cipher.update

    rsa_key_generation_command = './host_tools/rsa/keygen'

    if not os.system(rsa_key_generation_command):
        log.info("Asymetric key generation success")
    else:
        log.info("!!!!!!!!!!!!!Asymetric key generation failed!!!!!!!!!!!!!!!!!!!!!")
        return

    public_key = get_public_key()

    # log.info("public key:")
    # log.info(public_key.hex())

    write_eeprom_bin(key_v, key_f, key_c, public_key)
    # write_eeprom_bin(key_v, key_f, key_c)
    

if __name__ == "__main__":
    main()
